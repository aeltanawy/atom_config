"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var React = _interopRequireWildcard(require("react"));

var _context = _interopRequireDefault(require("./context"));

var _provider = _interopRequireDefault(require("./provider"));

var types = {
  ascii: "asciimath",
  tex: "tex"
};

var MathJaxNode_ =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(MathJaxNode_, _React$Component);

  function MathJaxNode_(props) {
    var _this;

    (0, _classCallCheck2.default)(this, MathJaxNode_);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MathJaxNode_).call(this, props));
    _this.nodeRef = React.createRef();
    return _this;
  }
  /**
   * Render the math once the node is mounted
   */


  (0, _createClass2.default)(MathJaxNode_, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.typeset();
    }
    /**
     * Update the jax, force update if the display mode changed
     */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var forceUpdate = prevProps.inline !== this.props.inline || prevProps.children !== this.props.children;
      this.typeset(forceUpdate);
    }
    /**
     * Clear the math when unmounting the node
     */

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clear();
    }
    /**
     * Clear the jax
     */

  }, {
    key: "clear",
    value: function clear() {
      var MathJax = this.props.MathJax;

      if (!MathJax) {
        return;
      }

      if (!this.script) {
        return;
      }

      var jax = MathJax.Hub.getJaxFor(this.script);

      if (jax) {
        jax.Remove();
      }
    }
    /**
     * Update math in the node
     * @param { Boolean } forceUpdate
     */

  }, {
    key: "typeset",
    value: function typeset() {
      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var MathJax = this.props.MathJax;

      if (!MathJax || !MathJax.Hub) {
        throw Error("Could not find MathJax while attempting typeset! It's likely the MathJax script hasn't been loaded or MathJax.Context is not in the hierarchy.");
      }

      var text = this.props.children;

      if (forceUpdate) {
        this.clear();
      }

      if (forceUpdate || !this.script) {
        this.setScriptText(text);
      }

      if (!this.script) return;
      var reprocess = ["Reprocess", MathJax.Hub, this.script];

      if (!this.props.onRender) {
        MathJax.Hub.Queue(reprocess);
      } else {
        MathJax.Hub.Queue(reprocess, this.props.onRender);
      }
    }
    /**
     * Create a script
     * @param { String } text
     */

  }, {
    key: "setScriptText",
    value: function setScriptText(text) {
      var inline = this.props.inline;
      var type = types[this.props.input];

      if (!this.script) {
        this.script = document.createElement("script");
        this.script.type = "math/".concat(type, "; ").concat(inline ? "" : "mode=display");
        this.nodeRef.current.appendChild(this.script);
      } // It _should_ be defined at this point, we'll just return at this point now


      if (!this.script) {
        return;
      }

      if ("text" in this.script) {
        // IE8, etc
        this.script.text = text;
      } else {
        this.script.textContent = text;
      }
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement("span", {
        ref: this.nodeRef
      });
    }
  }]);
  return MathJaxNode_;
}(React.Component);

var MathJaxNode =
/*#__PURE__*/
function (_React$PureComponent) {
  (0, _inherits2.default)(MathJaxNode, _React$PureComponent);

  function MathJaxNode() {
    (0, _classCallCheck2.default)(this, MathJaxNode);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MathJaxNode).apply(this, arguments));
  }

  (0, _createClass2.default)(MathJaxNode, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return React.createElement(_context.default.Consumer, null, function (_ref) {
        var MathJax = _ref.MathJax,
            input = _ref.input,
            hasProviderAbove = _ref.hasProviderAbove;

        // If there is no <Provider /> in the above tree, create our own
        if (!hasProviderAbove) {
          return React.createElement(_provider.default, null, React.createElement(MathJaxNode, _this2.props));
        }

        if (!MathJax) {
          return null;
        }

        return React.createElement(MathJaxNode_, {
          inline: _this2.props.inline,
          onRender: _this2.props.onRender,
          input: input,
          MathJax: MathJax,
          hasProviderAbove: hasProviderAbove
        }, _this2.props.children);
      });
    }
  }]);
  return MathJaxNode;
}(React.PureComponent);

(0, _defineProperty2.default)(MathJaxNode, "defaultProps", {
  inline: false,
  onRender: null
});
var _default = MathJaxNode;
exports.default = _default;